SRC_C = 01_hello.c 03_visibility.c 
SRC_CXX = 02_hello.cpp 04_extern.cpp
CC = cc
CXX = c++

OBJ = $(SRC_C:.c=.o) $(SRC_CXX:.cpp=.o)

all: $(OBJ)


format: $(SRC) 
	@clang-format -i $^ 2>/dev/null || echo "Please install clang-format to run this commands"

clean:
	@rm -f *~ *.x *.o *.s

.PHONY: clean all format

# 01
# if you compile with flag -fno-builtin, then when checking at the symbols (with nm object.o) they may be more (informative? only puts->printf changes)

# 02
# In C u identify a symbol (variable or function) by its name. Therefore you can't have more functions with the same name, they would have the same symbol name!
# C++ allows function overloading, the generated symbols are unique, they differ in the last part of the name (usually last letter is different)
# Symbols generated by C compiler are easy and simple, but different from the ones generated from C++ compiler

# 03
# always remember that static means internal linkage
# symbols in nm. Lower case? static (internal linkage)
# val1 is r cause it's a const (you can only read it)
# r = read     d = data

# what to linkers do? they resolve the symbols (of the object files)

# 04
# extern "C" means "please create symbols with C notation"
# if I'd add in the program printf("hhh") (a C func in a c++ code) the function printf will have anyway the C symbol convention
